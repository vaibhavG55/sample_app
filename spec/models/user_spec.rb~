require 'spec_helper'

describe User do
   
   before{@user = User.new(name:"Example User",email: 'user@example.com',
                           password: "foobar", password_confirmation: "foobar")}
   
   subject{@user}
   
   it{should respond_to(:name)}
   it{should respond_to(:email)}
   it{should respond_to(:password_digest)}
   it{should respond_to(:password)}
   it{should respond_to(:password_confirmation)}
   it{should respond_to(:remember_token)}
   it{should respond_to(:admin)}
   it{should respond_to(:authenticate)}
   it{should respond_to(:microposts)}
   it{should respond_to(:feed)}
   it{should respond_to(:relationships)}
   it{should respond_to(:followed_users)}
   it{should respond_to(:follow!)}
   it{should respond_to(:following?)}
   it{should respond_to(:unfollow!)}
   it{should respond_to(:followers)}
   it{should respond_to(:reverse_relationships)}
   
   it{ should be_valid}
   it{should_not be_admin}
   
#   before_save { self.email.downcase! }
   describe "when name is not present" do
      before{@user.name = ""}
      it{should_not be_valid}
   end
   
   describe "with admin attribute set to 'true'" do
      before { @user.toggle!(:admin) }
      it { should be_admin }
   end
   
   describe "when email is not present" do
      before{@user.email = ""}
      it{should_not be_valid}
   end
   
   describe "when length is greater than 50" do
      before{@user.name = "a" * 51}
      it{should_not be_valid}
   end
   
   describe "when email format is invalid" do
     it "should be invalid" do
      addresses = %w[user@foo,com user_at_foo.org example.user@foo.
                    foo@bar_baz.com foo@bar+baz.com]
      addresses.each do |invalid_address|
       @user.email = invalid_address
       @user.should_not be_valid
      end
     end
   end
   
   
   describe "when email format is valid" do
     it "should be valid" do
      addresses = %w[user@foo.COM A_US-ER@f.b.org frst.lst@foo.jp a+b@baz.cn]
      addresses.each do |valid_address|
       @user.email = valid_address
       @user.should be_valid
      end
     end
   end
   
   describe "when user is duplicate" do
      before{
       user_dup = @user.dup
       user_dup.email = @user.email.upcase
       user_dup.save 
      }
      it{should_not be_valid}
   end
   
   describe "when password is empty" do
       before{@user.password = @user.password_confirmation = ""}
       it{should_not be_valid}
   end
   
   describe "when mismatch between password and confirmation" do
       before{@user.password_confirmation = "mismatch"}
       it{should_not be_valid}
   end
   
   describe "when password_confirmation is nil" do 
      before { @user.password_confirmation = nil }
      it { should_not be_valid }
   end
   
   describe "describe the return value of authenticate method" do
      before{@user.save}
      let(:found_user){User.find_by_email(@user.email)}
      
      describe "user with valid password" do
         it{should == found_user.authenticate(@user.password)}
      end
      
      describe "user with invalid password" do
         let(:user_for_invalid_password) { found_user.authenticate("invalid") }
         it{should_not == user_for_invalid_password}
         specify { user_for_invalid_password.should be_false }
      end
   end
   
   describe "password of length less than 6"do
       before{@user.password = @user.password_confirmation = "a"*5}
       it{should_not be_valid}
   end
   
   describe "email address with mixed case" do
     let(:mixed_case_email) { "Foo@ExAMPle.CoM" }
     it "should be saved as all lower-case" do
       @user.email = mixed_case_email
       @user.save
       @user.reload.email.should == mixed_case_email.downcase
      end
   end
   
   describe "remember token" do
      before{@user.save}
      its(:remember_token){should_not be_blank}
   end
   
   describe "microposts association" do
      before {@user.save}
      let!(:older_micropost) do
        FactoryGirl.create(:micropost,user: @user, created_at: 1.day.ago)
      end
      let!(:newer_micropost) do
        FactoryGirl.create(:micropost,user: @user, created_at: 1.hour.ago)
      end
      
      it "should have microposts in right order" do
         @user.microposts.should == [newer_micropost,older_micropost]
      end
      
      it "should destroy associated micoposts" do
         microposts = @user.microposts
         @user.destroy
         
         microposts.each do |micropost|
            Micropost.find_by_id(micropost.id).should be_nil
         end
      end
      
      describe "status" do
         let(:unfollowed_post){FactoryGirl.create(:micropost,user: FactoryGirl.create(:user))}
         let(:followed_user){FactoryGirl.create(:user)}
         before do
            @user.follow!(followed_user)
            3.times { followed_user.microposts.create!(content: "Lorem ipsum") }
         end
         
         its(:feed){should include(newer_micropost)}
         its(:feed){should include(older_micropost)}
         its(:feed){should_not include(unfollowed_post)}
      end
      
   end
   
   describe "following" do
      let(:other_user){FactoryGirl.create(:user)}
      before do
         @user.save
         @user.follow!(other_user)
      end
      
      it{should be_following(other_user)}
      its(:followed_users){should include(other_user)}
      
      describe "followers" do
         subject{other_user}
         its(:followers){should include(@user)}
      end
      
      describe "and unfollowing" do
         before{@user.unfollow!(other_user)}
         
         it{should_not be_following(other_user)}
         its(:followed_users){should_not include(other_user)}
      end
      
   end
   
end
